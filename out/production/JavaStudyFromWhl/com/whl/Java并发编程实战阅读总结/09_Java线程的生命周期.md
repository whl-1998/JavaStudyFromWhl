# 线程的生命周期

在Java中实现并发程序的主要手段就是多线程，Java通过对操作系统层面的线程进行了封装，提供了可操作线程的API给我们使用。  

而在操作系统层面，线程也是存在生命周期的，通用的线程声明周期可以用五个状态进行描述：
1. **初始状态**：指的是线程刚被创建，但还不允许为其分配CPU时间片的状态。这里的初始状态可以认为是在编程层面线程被创建，但在操作系统层面线程还未被创建。
2. **可运行状态**：指的是允许操作系统为线程分配CPU时间片的状态，但分配了时间片后线程还未真正执行。
3. **运行状态**：当操作系统发现有空闲CPU时，会把一个处于可运行状态的线程分配给这个空闲CPU执行，此时这个线程就进入了运行状态。
4. **休眠状态**：当运行状态的线程调用了一个阻塞的API或等待某个事件时（例如阻塞的文件读取操作），线程就会释放它占有的CPU资源，从运行状态转换为休眠状态，处于休眠状态的线程是永远无法获得CPU使用权的。当事件执行完毕后，线程从休眠状态转化为可运行状态，等待被调度执行后续的操作。
5. **终止状态**：当线程执行完毕或者出现异常就会进入到终止状态，终止状态的线程就意味着生命周期的结束，并且是不可逆的。

而在Java中，对这5个状态的某些地方进行了细化与合并，在Java中线程存在下面六个状态（你可以在Thread.State中看到这些状态的枚举）：

#### 1. NEW
与初始状态基本相同，在Java中```Thread t = new Thread();```执行后就创建了一个新生线程。

值的注意的是：在Java中，如果要让线程 t 进入RUNNABLE状态，需要调用start()方法，在start()方法的源码中明确标注了只有当线程的状态是NEW才能正确执行，否则会抛出IllegalThreadStateException。

#### 2. RUNNABLE
Java中将操作系统层面的可运行状态与运行状态进行了合并，当我们调用```t.start();```之后，就通知操作系统为线程 t 分配CPU时间片，处于RUNNABLE状态的线程可能处于执行中，也可能处于刚被分配时间片的状态。

值的注意的是：当线程调用某个阻塞式API时，在操作系统层面会进入休眠状态，但是在JVM层面线程依旧会保持RUNNABLE的状态。所以在提到Java调用某个阻塞API使线程进入阻塞状态指的是操作系统层面的休眠态，而不是Java线程的阻塞状态。

####  3. BLOCKED
当线程在等待获取synchronized锁时就会进入阻塞状态，并且在操作系统层面中，线程可能会进入休眠状态。为什么是“可能”呢？  

在早期synchronized作为重量级锁使用的时候，线程等待获取锁时确实会进入休眠状态，而休眠到唤醒这个过程进行了一次用户态到内核态的转换，效率很低。在Java6以后对synchronized进行了一系列优化，使得线程在某些低并发的场景下通过偏向或自旋等待完成获取锁的过程，这样线程就保持着CPU的占用，不涉及上下文切换动作。

####  4. WAITING：
当调用Object.wait()或Thread.join()、LockSupport.park()时会使线程进入WAITING状态，在这个状态下，线程会释放掉本身占有的锁并进入等待池，不会再参与锁争夺，直到被唤醒为止。

#### 5. TIMED_WAITING
正如其名，是WAITING状态的计时版，当调用Thread.sleep(long time)、Object.wait(long time)、Thread.join(long time)等方法，线程会进入计时等待状态，到达指定时间后被操作系统自动唤醒。需要注意的是：处于TIMED_WAITING的线程不会释放锁。

#### TERMINAL
无论是正常退出还是抛出异常，线程的使命都已完成，进入TERMINAL状态，并且该状态不可逆。

# 创建多少线程合适
在Java中，实现并发的主要手段就是多线程，创建线程与对象不同，需要调用操作系统的内核API，为线程分配一系列的资源，这个成本是相当高的。因此创建多少个线程合适就是一个大问题。  

要想提升程序的性能基本上可以通过两个方向，一个是优化算法，另一个就是将硬件的性能发挥到极致。那么如果要通过后者实现性能提升，就需要通过多线程实现。要想将硬件性能发挥到极致，就需要通过并发编程提高IO设备与CPU的利用率。

假设CPU计算与IO操作的耗时是1:1，如果通过单线程执行，CPU计算的时候，IO空闲；IO执行的时候，CPU空闲，因此两者的利用率都是百分之50。
![单线程执行](https://static001.geekbang.org/resource/image/d1/22/d1d7dfa1d574356cc5cb1019a4b7ca22.png)

如果有两个线程同时执行，当线程A在执行IO操作时，线程B执行CPU计算；当线程B在执行IO操作时，线程A执行CPU计算。也就是两者交叉执行，因此利用率就都是百分之百。

![多线程执行](https://static001.geekbang.org/resource/image/68/2c/68a415b31b72844eb81889e9f0eb3f2c.png)

既然增加线程能够使得IO和CPU的利用率都能够提高，那么在IO和CPU的利用率都很低的情况下，可以适当增加线程来提高吞吐量（单位时间内执行请求的数量）。  

在单核CPU时代，多线程主要就是用于平衡IO和CPU的，如果程序只有CPU计算，没有IO操作的话，多线程不但不会提高性能，反而会使得性能变得更差，原因在于一次线程切换是需要一定的成本的。就好比写作业写一会儿停一会儿的效率一定不比一直写的效率高。  

但是在多核CPU时代，这类纯CPU计算的程序也可以通过多线程来提高效率。这时就可以看作你有多个大脑，一个大脑负责计算第一题，另一个大脑负责计算第二题，效率自然成倍增长。  

当今我们的计算机大多都是具备多核CPU的，但创建多少个线程也还是需要通过具体的场景去判断。而这些场景又以IO和CPU执行时长又分为IO密集型和CPU密集型。  

对于CPU密集型，本质上是提高多核CPU的利用率，所以对一个4核的CPU，每个核一个线程，理论上4个线程就能够保证CPU的执行效率是100%的了，再创建更多的线程也只是增加切换线程的成本。但是在工程上，一般线程数量会设置在“CPU核数”+1，这是为了保证某个线程失效或者因为其他原因阻塞时，这个额外的线程可以顶上，从而保证CPU利用率。  

而对于IO密集型，单核CPU的最佳线程数 = 1 + （IO耗时/CPU耗时），例如：IO耗时:CPU耗时 = 4 : 1，那么理论上需要5个线程，4个线程负责IO，1个线程负责CPU计算。再加上额外的一个线程保证突发情况的利用率，因此是6个。而多核CPU的最佳线程数只需要等比扩大即可：CPU 核数 * [ 1 +（I/O耗时/CPU耗时）]
















