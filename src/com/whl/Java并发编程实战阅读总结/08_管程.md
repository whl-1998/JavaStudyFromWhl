### 管程

管程，Monitor，也被翻译为监视器，它指的是管理变量以及对共享变量的操作过程，让他们支持并发。管程存在三种模型，分别是MESA、Hasen、Hoare，其中运用最广泛的就是MESA模型，并且Java管程实现参考的也是MESA模型。

管程主要是用来解决互斥、同步这两个并发编程中的核心问题，互斥指的是同一时刻只允许一个线程访问共享资源；同步指的是线程之间该如何通信，协作。

管程解决互斥问题的思路，就是将共享变量以及对共享变量的操作统一封装，例如下图中，管程X将共享变量queue以及相关的入队、出队操作都封装了，当线程想要访问共享变量时，只能通过入队、出队方法实现。

![管程](https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png)

当存在两个线程想要访问共享变量queue时，只能允许其中一个线程进入管程，然后调用deq()获取到共享变量，当对变量操作结束后调用enq()将共享变量交还给队列。

管程解决同步问题的步骤可以如下图所示：

<img src="https://static001.geekbang.org/resource/image/83/65/839377608f47e7b3b9c79b8fad144065.png" alt="img" style="zoom:70%;" />

当多个线程试图进入管程内部时，只允许一个线程进入，这个是管程保证的互斥性。管程中还引入了条件变量的概念，这个条件变量就是用来解决同步问题的。每一个条件变量都对应着一个等待队列，当进入管程中的线程如果不满足条件时会进入条件变量等待队列，当符合条件后线程会从队列出队，并再次进入入口等待队列继续试图进入管程获取共享变量。

例如，一个线程A进入到管程，准备调用deq()方法从queue队列中获取共享变量，然而队列此时为空，那么就不满足 !queue.isEmpty() 这个条件（可能其他线程已经把资源取完了），此时线程A就会调用wait()方法，进入条件变量等待队列等待某个线程释放资源后调用notify/notifyAll唤醒它，当线程A被唤醒后，从条件变量等待队列出队，再次进入入口等待队列试图进入管程。

我们可以通过一个阻塞队列对管程的互斥、同步进行说明：

```java
public class BlockedQueue<T> {
    final Lock lock = new ReentrantLock();
    // 条件变量：队列不满  
    final Condition notFull = lock.newCondition();
    // 条件变量：队列不空  
    final Condition notEmpty = lock.newCondition();

    // 入队
    void enq(T x) {
        //获取锁
        lock.lock();
        try {
            //队列满了无法入队, 需要等待消费线程执行出队操作
            while (队列已满) {
                // 让当前线程进入等待状态, 直到队列不满被唤醒
                notFull.await();
            }
            // 省略入队操作...
            // 入队后, 唤醒那些在等待"队列不为空"的线程
            notEmpty.signal();
        }finally {
            lock.unlock();
        }
    }
    
    // 出队
    void deq(){
        lock.lock();
        try {
            //当队列为空时, 就需要等待生产者线程执行入队操作
            while (队列已空) {
                // 当当前线程进入等待状态, 直到队列不为空时被唤醒
                notEmpty.await();
            }
            // 省略出队操作...
            //出队后，唤醒那些在等待"队列不满"的线程
            notFull.signal();
        }finally {
            lock.unlock();
        }  
    }
}
```



需要注意的是，对于MESA管程来说，有一个编程范式，就是需要在while()中调用wait()。例如上述代码，当线程B通知线程A后，线程B还会继续执行，但线程A并不立即执行，仅仅是从等待条件变量的队列进入到入口等待队列。也就是说，当线程A再次进入条件判断时，曾经满足的条件此时可能不满足了，所以需要循环的方式检验条件变量。



### 问题汇总

##### wait() 方法在 Hasen 模型和 Hoare 模型里面，都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要吗？

有必要，当某个线程不满足条件，调用wait()进入条件等待队列时，如果没有其他线程唤醒就会一直处于等待状态。与其傻等，不如等一段时间就重新进入入口等待队列，再次进行一次条件判断。