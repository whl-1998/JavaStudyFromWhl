# 线程的生命周期

在Java中实现并发程序的主要手段就是多线程，Java通过对操作系统层面的线程进行了封装，提供了可操作线程的API给我们使用。  

而在操作系统层面，线程也是存在生命周期的，通用的线程声明周期可以用五个状态进行描述：
1. **初始状态**：指的是线程刚被创建，但还不允许为其分配CPU时间片的状态。这里的初始状态可以认为是在编程层面线程被创建，但在操作系统层面线程还未被创建。
2. **可运行状态**：指的是允许操作系统为线程分配CPU时间片的状态，但分配了时间片后线程还未真正执行。
3. **运行状态**：当操作系统发现有空闲CPU时，会把一个处于可运行状态的线程分配给这个空闲CPU执行，此时这个线程就进入了运行状态。
4. **休眠状态**：当运行状态的线程调用了一个阻塞的API或等待某个事件时（例如阻塞的文件读取操作），线程就会释放它占有的CPU资源，从运行状态转换为休眠状态，处于休眠状态的线程是永远无法获得CPU使用权的。当事件执行完毕后，线程从休眠状态转化为可运行状态，等待被调度执行后续的操作。
5. **终止状态**：当线程执行完毕或者出现异常就会进入到终止状态，终止状态的线程就意味着生命周期的结束，并且是不可逆的。

而在Java中，对这5个状态的某些地方进行了细化与合并，在Java中线程存在下面六个状态（你可以在Thread.State中看到这些状态的枚举）：

#### 1. NEW
与初始状态基本相同，在Java中```Thread t = new Thread();```执行后就创建了一个新生线程。

值的注意的是：在Java中，如果要让线程 t 进入RUNNABLE状态，需要调用start()方法，在start()方法的源码中明确标注了只有当线程的状态是NEW才能正确执行，否则会抛出IllegalThreadStateException。

#### 2. RUNNABLE
Java中将操作系统层面的可运行状态与运行状态进行了合并，当我们调用```t.start();```之后，就通知操作系统为线程 t 分配CPU时间片，处于RUNNABLE状态的线程可能处于执行中，也可能处于刚被分配时间片的状态。

值的注意的是：当线程调用某个阻塞式API时，在操作系统层面会进入休眠状态，但是在JVM层面线程依旧会保持RUNNABLE的状态。所以在提到Java调用某个阻塞API使线程进入阻塞状态指的是操作系统层面的休眠态，而不是Java线程的阻塞状态。

####  3. BLOCKED
当线程在等待获取synchronized锁时就会进入阻塞状态，并且在操作系统层面中，线程可能会进入休眠状态。为什么是“可能”呢？  

在早期synchronized作为重量级锁使用的时候，线程等待获取锁时确实会进入休眠状态，而休眠到唤醒这个过程进行了一次用户态到内核态的转换，效率很低。在Java6以后对synchronized进行了一系列优化，使得线程在某些低并发的场景下通过偏向或自旋等待完成获取锁的过程，这样线程就保持着CPU的占用，不涉及上下文切换动作。

####  4. WAITING：
当调用Object.wait()或Thread.join()、LockSupport.park()时会使线程进入WAITING状态，在这个状态下，线程会释放掉本身占有的锁并进入等待池，不会再参与锁争夺，直到被唤醒为止。

#### 5. TIMED_WAITING
正如其名，是WAITING状态的计时版，当调用Thread.sleep(long time)、Object.wait(long time)、Thread.join(long time)等方法，线程会进入计时等待状态，到达指定时间后被操作系统自动唤醒。需要注意的是：处于TIMED_WAITING的线程不会释放锁。

#### TERMINAL
无论是正常退出还是抛出异常，线程的使命都已完成，进入TERMINAL状态，并且该状态不可逆。
