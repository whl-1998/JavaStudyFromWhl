### 局部变量与调用栈

我们都知道局部变量是线程安全的，只有多个线程操作共享变量时才可能引发线程安全问题。那局部变量为什么是线程安全的呢？

局部变量的作用域是方法内部，当方法执行完毕，局部变量的生命周期也随之结束。局部变量是存放在CPU调用栈里的，每当调用一个方法，就会创建一个新的栈帧压入调用栈，这个栈帧就存放了方法需要的参数和返回地址。具体来说，局部变量其实是存放在调用栈的栈帧中的。

Java中，每个线程都有自己的调用栈，而局部变量就保存在各自线程的调用栈中，**并不会共享，所以也就没有并发问题**。



### 线程封闭

“不共享就不会有并发问题”，这个思路已经成为了解决并发问题的一门重要技术，行话叫“线程封闭”，我们熟知的ThreadLocal也就是采用线程封闭思想来设计的。



### 问题汇总

##### 1. 递归调用太深，可能导致栈溢出。你思考一下原因是什么？有哪些解决方案呢

递归也就是方法调用自己，每递归一次都会创建一个新的栈帧，并且还需要保留之前的栈帧。当递归层数过多，就很可能导致调用栈中栈帧过多从而导致栈溢出。解决方案很简单：将递归方法优化为记忆化递归或者采用动态规划即可。