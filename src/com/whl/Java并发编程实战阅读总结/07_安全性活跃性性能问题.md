并发编程中，主要存在三个问题，分别是：安全性问题、活跃性问题、性能问题。

### 安全性问题

我们常听到类似这样的描述：这个方法是/不是线程安全的，这个线程安全就是在并发环境下，程序是否会按照我们的预期执行，在01中已经总结了并发问题的三个源头：原子性、有序性、可见性。理论上线程安全的程序就是要保证这三个特性。

但也不是所有代码都需要分析上面的三个问题，当多个线程同时读写同一份数据时，只要保证这个数据不共享或是不可变，也能够保证线程安全。例如ThreadLocal、不变模式等都是基于这个理论实现的。

但有时候，我们也必须共享会发生变化的数据，当多个线程同时访问某个数据，并且至少有一个线程会写这个数据的时候，如果不采取防护措施，就很有可能导致并发bug。为此我们可以对共享数据加锁，以保证互斥性，但加锁也不能乱加，否则也无法保证并发安全，例如下列代码：

```java
public class Test {
    private long count = 0;
    
    synchronized long get() {
        return count;
    }
    
    synchronized void set(long v){
        count = v;
    }
    
    void add10K() {
        int idx = 0;
        while(idx++ < 10000) {
            set(get()+1)      
        }
    }
}
```

假设线程A与线程B同时执行add10K()方法，线程A、B都通过get()方法读取到了count=0，当线程A执行了count+1这个操作时（注意还未执行set()方法），线程B执行了count+1并且执行了set()方法并将count回写，此时count=1。而线程A还会继续执行后续的set()方法，回写后count还是=1。这就是由于没有保证原子性带来的并发Bug，说白了就是没有正确加锁。要修改也很简单，将get()和set()方法的synchronized去掉，改为add10K()加上synchronized就可以了。



### 活跃性问题（活锁、饥饿）

活跃性问题，指的是某个操作无法执行下去了。常见的“死锁”就是典型的活跃性问题，除了死锁以外还存在两种情况，分别是“活锁”、“饥饿”。

想象一下，当线程A与线程B各自都持有自己的锁，尝试获取对方的锁。当A、B尝试获取对方的锁失败，会释放自己持有的锁，再重复获取自己的锁，尝试获取对方的锁。如果A、B都是同时释放，同时获取，也可能造成A、B不断尝试都无法成功获取到对方的锁。解决活锁的方法很简单，如果发生活锁的情况，让线程随机等待一段时间后再继续争夺即可。

解决“饥饿”的问题也很简单，有三种方案：

1. 保证资源充足
2. 公平锁
3. 避免持有锁的线程长时间执行



### 性能问题

使用锁的时候，也需要注意锁的范围，如果锁得太广就可能出现性能问题。解决性能问题的方案主要有两种：

1. 将锁细粒度化（例如ConcurrentHashMap）
2. 使用原子类、ThreadLocal、CopyOnWrite、乐观锁等技术