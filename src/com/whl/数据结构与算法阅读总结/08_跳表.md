### 一、跳表的概念

之前提到过，二分查找底层依赖的是数组随机访问的特性，因此只能用数组实现。但如果是在链表中使用二分查找，因为链表随机访问时间复杂度为O(n)的特性，强行使用二分查找反而适得其反。但我们可以对链表结构稍作改造，就能够使链表支持类似 “二分” 的查找算法，这种数据结构就是跳表。

对于一个单链表，即便链表中存储的数据都是有序的，如果我们想要检索其中的某个数据，也只能通过从头到尾遍历链表，这样的查找效率是很低的，时间复杂度为O(n)。但我们可以采用空间换时间的优化策略，对链表建立一个“一级索引”，每个索引可以跨两步，这样优化了查找的效率。

![img](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

假设我们要查找上图链表中值 == 16的结点，首先在索引层遍历，当遍历到结点13时，发现下一个结点是17，那么可以断定要查找的16结点一定在结点13和结点17之间。于是通过down指针下降到原始链表层，此时只需要从结点13遍历到下一个结点，就成功获取到了值 == 16的结点。相比起原始链表需要遍历10个结点来看，加上一级索引的链表只需要遍历7个结点。

如果我们再加上一个二级索引，还可以遍历得更快：

![img](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

通过二级索引，我们只需要跨6步就能够找到目标结点。

跳表的索引级数一般是链表长度的logN个，检索时用到的索引级数 = logX。例如我们要从64个结点的链表中检索value=62的结点，log62 = 5，只需要从5级索引开始，依次遍历到value = 62的结点即可，总共只需要遍历11个结点，相比起链表原始的遍历快了很多。

![img](https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg)

跳表虽然相比起传统链表，遍历效率提高了不少，但是涉及到增删操作时，为了保证索引的有效，必须要在增、删操作后动态地维护索引结点，这一点倒是和AVL的左旋、右旋差不多。因此，总体上来说，跳表更加适合那些增、删操作不那么频繁的场景。



### 二、为什么 Redis 要用跳表来实现有序集合，而不是红黑树

Redis中，有序集合支持的核心操作有如下几个：

1. 插入一个数据
2. 删除一个数据
3. 查找一个数据
4. 按照区间查找数据（范围查询）
5. 迭代输出有序序列

其中，插入、删除、查找、迭代输出这几个操作，红黑树也能够完成，且时间复杂度与跳表一样。但是，按照区间查询数据这个操作，红黑树的效率则没有跳表高。对于区间查询这个操作，跳表可以做到O(logN)的时间复杂度来定位区间起点，然后只需要在原始链表中向后遍历即可。

除此以外，跳表相比起红黑树要更加简单、可读性好、也不易出错。不过跳表当前并没有现成的实现，如果要在开发中使用跳表，必须自己手动实现；而红黑树，在Java中已经提供了TreeMap的实现。