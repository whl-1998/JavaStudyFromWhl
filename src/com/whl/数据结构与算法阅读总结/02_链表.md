从01讲中，我们能够得知，数组需要一块连续的内存空间来存储相同类型数据，这就意味着：假设我们需要申请100MB大小的数组，如果内存中没有连续的、足够大的存储空间时，即便内存剩余的可用空间满足100MB，也会申请失败。

而链表恰恰相反，并不需要一块连续的内存空间。它通过“指针”将一组零散的内存块串联起来使用，这就意味着：假设我们需要申请100MB大小的链表，即便内存中没有连续的，足够大的内存空间时，只要剩余空间满足100MB，就可以成功申请。



**链表的增、删、随机访问：**

我们知道链表的增、删时间复杂度是O(1)的，这是因为在执行链表的增、删时，不需要为了保证数据的连续性而搬迁结点，只需要考虑增加、删除结点相邻的两个节点之间的指针改变，如图所示：

![img](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)

而链表的随机访问的效率就相对较低了，时间复杂度为O(n)，由于数据并非连续存储，只能通过指针一个结点一个结点地遍历才能找到相应的结点。



### 双向链表

链表一般具备三种形态：单链表、双向链表、循环链表。一般循环链表可以用来解决环状结构的问题，而工程应用中更多的则是采用双向链表，例如Java中的LinkedList底层就是双向链表实现的。

双向链表顾名思义，一个结点有两个指针：后继指针next指向后面的结点，前驱指针prev指向前面的结点。如下代码所示：

```java
Node {
 	int data;
    Node prev;
    Node next;
	...    
}
```

相比起单链表，双向链表的一个结点需要占用更多的内存空间，但好处是插入、删除的操作相比起单链表要更加简单、高效。

例如在实际开发中，从链表删除一个数据无外乎下面两种情况：

1. 删除链表中 “Node.value = 指定value” 的结点

2. 删除给定指针指向的结点

对于第一种情况，无论单链表、双向链表，为了检索到对应value的结点，都需要从头结点开始一个一个遍历，直到找到指定结点才能删除。尽管删除操作的时间复杂度是O(1)，但耗时的操作主要花在遍历上，遍历结点的复杂度为O(n)，因此第一种情况的时间复杂度为O(n)。

对于第二种情况，如果已经找到了要删除的结点，但是删除该结点需要知道其前驱结点，而单链表并不能直接获取到前驱结点。因此为了找到前驱结点，还需要从头结点遍历一次链表，直到Node.next = waitingForDeleteNode，才能获取到前驱结点。而双向链表在这种情况就非常具有优势，直接通过prev指针就能够获取到前驱结点。因此针对第二种情况，单链表的删除时间复杂度为O(n)、双向链表的时间复杂度为O(1)。

除了增加、删除的操作，对于一个有序的链表，双向链表的等值查询效率也要更高一些。可以记录上一次查找的位置p，在每一次查找时，根据要查找的值与p的大小关系，决定往前还是往后查找，因此效率比起单链表要更高。

其实，双向链表的核心思想就是——空间换时间。在内存空间充足的时候，我们为了追求代码的执行速度，可以选择空间复杂度较高、时间复杂度较低的数据结构或算法。空间换时间的思想应用广泛，例如缓存就是典型的空间换时间策略。如果是检索硬盘上的数据，那么IO读写是非常耗时的，如果事先将数据加载到内存，虽然耗费内存空间，但是每次数据检索的效率就高很多。动态规划也是典型的空间换时间算法思想（本质还是缓存）。



### 链表vs数组

数组在事先上使用的是连续的内存空间，因此可以借助CPU提供的缓存机制预读数组中的数据，因此访问效率更高。而链表则不支持预读机制。

链表中的每个结点都要消耗额外的内存空间去存储指向下一个结点的指针，因此内存消耗较高。除此以外，对链表的频繁插入、修改操作也会导致频繁的内存申请、释放，容易造成内存碎片。如果是Java，则会导致频繁的垃圾回收动作。