### 一、递归的概念

在学习递归之前，可以先想象一个场景：假设你在进行英语考试，发现有道题不会做，于是你去问旁边的同学 A 这道题怎么做。恰好 A 也不会做，于是 A 就问他旁边的同学 B 这道题怎么做。而 B 恰好也不会做，于是 B 又问他旁边的同学 C 就这样一直问下去，最终在同学 E 那里问到了答案。于是同学 D 将获取到的答案回传给 C ，C 又将答案回传给 B .... 最终你会从同学 A 那里获取到答案。

上述场景转换为代码就是：

```java
Answer f(Classmate n) {
    //如果当前同学知道答案, 那么返回答案
	if (Classmate.hasAnswer()) return answer;
    //如果当前同学不知道答案, 则问下一个同学
	return f(nextClassmate);
}
```

从上面这个场景我们能够得知，递归需要满足三个条件：

1. **一个问题的解可以转换为n个子问题的解**

   例如，上述场景中 “得到某道英语题答案的解” 可以转换为 “旁边的同学是否知道这道题的解”。（要注意，为了便于理解，上述案例只是将总问题转换为了一个子问题，而大部分递归题是将总问题转换为n个子问题）

2. **当前总问题与分解之后的子问题求解思路相同**

   例如，上述场景中，同学A求“某道英语题答案的解”与同学C、D的方式相同。

3. **存在递归终止条件**

   例如，上述场景中，同学 E 可以直接给出问题的答案，这就是终止条件。



### 二、编写递归代码的思路

其实编写递归代码步骤很简单，只需要通过寻找到重复子问题，写出递推公式，且找到递归终止条件，剩下的就是将思路转换为代码了。但恰恰是 “寻找重复子问题，写出递推公式” 这个步骤是非常难的，这也是递归问题的痛点所在。

下面通过最经典的递归问题——爬楼梯（斐波那契）问题分析写递推解法的思路：

https://leetcode-cn.com/problems/climbing-stairs/

首先分析问题，1次爬楼梯只能上1级或2级台阶，那么第n级台阶只可能从n - 2级台阶和n - 1级台阶爬上来，那么第n级台阶的走法总数就可以是n - 1级台阶的走法总数加上n - 2级台阶的走法总数。为此我们可以得到如下递推公式：

```java
f(n) = f(n - 1) + f(n - 2);
```

有了递推公式，还需要寻找递归终止条件。当 n == 2时有两种走法（跨一次两级台阶、跨两次一级台阶），当 n == 1时只有一种走法（跨一次一级台阶），因此可以得到如下递归终止条件：

```java
if (n <= 2) return n;
```

到此，就可以将分析的思路转换为代码了，爬楼梯问题的题解如下：

```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    return climbStairs(n - 1) + climbStairs(n - 2);
}
```

爬楼梯问题在递归问题中，算是最最基础且简单的问题了，而对于大部分递归问题就没那么好分析了。要写好递归，我们要掌握正确的思路。首先最重要的一点就是**不要人肉递归**。递归本质上就是做重复的事情，对于递归代码，试图要想清楚整个递归的过程基本上是不可能的，例如爬楼梯问题中，当 n == 6 时，递归树就已经比较复杂了，更不要说 n == 10、100的递归树了。递归树如下图所示：

![img](https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg)

由此可见，要把整个递归流程全都想清楚基本不可能。因此，如果一个问题A可以被分解为问题B、C、D，那么可以假设问题B、C、D都已经解决，再在此基础上思考如何解决问题A即可。就好比你是一个大规模公司的老总，要一个人管好公司的所有员工是不可能的，你只需要管好经理们就ok了。



### 三、递归代码很可能出现的栈溢出问题

我们知道，每一次调用函数时，会在函数调用栈中保存该函数的临时变量栈帧，当函数执行完成后，栈帧才能出栈。而递归代码在每一次drill down时，都会保存上一层的栈帧，直到drill down到符合递归终止条件的那一层，才能开始返回栈帧。这就意味着，当递归的规模非常大的时候，需要保存的栈帧是成百上千的，这就很可能导致栈溢出StackOverflowError。

避免栈溢出的思路有三种：

1. 限制递归深度

   指定一个n值，当递归深度超过n就不再drill down，而是直接报错，这个方案虽然简单但是治标不治本。

2. 记忆化递归

   其实从之前爬楼梯问题的递归树中我们能够发现，该递归存在非常多的重复计算。我们可以用一个缓存保存计算结果，当下一次碰到同样的子问题时，就直接从缓存中获取，而不是重复计算一遍。爬楼梯问题的记忆化递归题解代码如下：

   ```java
   public int climbStairs(int n) {
       int[] cache = new int[n + 1];//缓存
       return recur(cache, n);
   }
   
   private int recur(int[] cache, int n) {
       if (cache[n] != 0) return cache[n];//如果缓存中有答案, 直接从缓存中获取, 没有再计算
       if (n <= 2) return n;
       return cache[n] = recur(cache, n - 1) + recur(cache, n - 2);// 保存计算结果到缓存
   }
   ```

3. 动态规划

   其实记忆化递归的思路和动态规划非常相似，简单来说动态规划包含三个步骤：状态定义、寻找递推方程、Coding，而记忆化递归其实已经完成前两个步骤了，剩下的就是将思路转换为代码：

   ```java
   public int climbStairs(int n) {
       if (n <= 2) return n;
       int[] dp = new int[n];//状态定义, 其实相当于缓存
       dp[0] = 1;
       dp[1] = 2;
       for (int i = 2; i < n; i++) {
           dp[i] = dp[i - 1] + dp[i - 2];//递推方程
       }
       return dp[n - 1];
   }
   ```

   其实理论上来说，所有递归问题都能够转化为动态规划进行解决。而且从时间复杂度来看，也是质变的优化。例如爬楼梯问题原本的递归解法时间复杂度是O(2^n)，而动态规划、记忆化递归只需要O(n)的时间复杂度就能解决问题。



### 四、给定一个用户 ID，如何查找这个用户的“最终推荐人”

假设现在要实现一个注册返佣金的功能，该功能要求：用户A推荐用户B注册，而用户B又推荐了用户C注册。可以说，用户C的 “最终推荐人” 为用户A，用户B的 “最终推荐人” 也是用户A，而用户A没有 “最终推荐人”。

这种推荐关系在数据表中如下所示：

![img](https://static001.geekbang.org/resource/image/29/0e/2984d45578440e9a348144c70d124a0e.jpg)

那么找到 “最终推荐人” 的代码可以如下：

```java
long findRootReferrerId(long actorId) {
    //检索一个用户id对应的referer_id
    Long referrerId = select referrer_id from [table] where actor_id = actorId;
    //如果该referer_id为空, 说明找到了最终推荐人, 则返回
    if (referrerId == null) return actorId;
    //否则递归寻找该referer_id对应的推荐人id
    return findRootReferrerId(referrerId);
}
```

但上述代码存在两个问题：

1. 如果递归层数很深，可能导致栈溢出的问题。该问题可以通过限制递归深度或记忆化递归解决。
2. 如果数据库中存在脏数据（例如用户A的推荐人是B，用户B的推荐人是C，C的推荐人是A），就可能造成死循环的问题。一般这种数据都是人为插入的测试数据。