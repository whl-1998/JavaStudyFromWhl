### 抽象类

下面这段代码是典型的抽象类使用场景——模版设计模式：

```java
// 抽象类：用于定义日志模版
public abstract class Logger {
    private String name;
    private boolean enabled;
    private Level minPermittedLevel;

    public Logger(String name, boolean enabled, Level minPermittedLevel) {
        this.name = name;
        this.enabled = enabled;
        this.minPermittedLevel = minPermittedLevel;
    }

    public void log(Level level, String message) {
        boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
        if (!loggable) 
            return;
        doLog(level, message);
    }

    //抽象方法
    protected abstract void doLog(Level level, String message);
}


// 抽象类的子类：用于输出日志到文件
public class FileLogger extends Logger {
    private Writer fileWriter;

    public FileLogger(String name, boolean enabled, Level minPermittedLevel, String filepath) {
        super(name, enabled, minPermittedLevel);
        this.fileWriter = new FileWriter(filepath); 
    }

    @Override
    public void doLog(Level level, String mesage) {
        // 格式化level和message, 输出到日志文件
        fileWriter.write(...);
    }
}

// 抽象类的子类：用于输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
    private MessageQueueClient msgQueueClient;

    public MessageQueueLogger(String name, boolean enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient) {
        super(name, enabled, minPermittedLevel);
        this.msgQueueClient = msgQueueClient;
    }

    @Override
    protected void doLog(Level level, String mesage) {
        // 格式化level和message, 输出到消息中间件
        msgQueueClient.send(...);
    }
}
```

上述代码中，Logger作为日志的抽象类，FileLogger、MessageQueueLogger继承自Logger，分别实现了不同的日志记录方式。FileLogger和MessageQueueLogger这两个子类复用了Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为两个子类写日志的方式不同，又各自重写了父类中的doLog()方法。

总结下来，抽象类具备下面三个特性：

1. 抽象类只能被继承，不允许被实例化。
2. 抽象类可以包含属性和方法，方法既可以是普通方法，也可以是抽象方法。
3. 子类继承抽象类，必须实现抽象类中所有的抽象方法。

因此，基于这些特性，抽象类常用于模版设计模式。抽象类实际上就是一种特殊的类，该类不能被实例化，只能被子类继承。可以说抽象类是一种“is a”的关系。



### 接口

接口主要用于对行为进行抽象，对约定与实现进行解耦，提高了代码的可扩展性。下面这段代码对“过滤”这个行为进行了抽象，分别实现了两个不同的过滤器：

```java
// 接口
public interface Filter {
    void doFilter(RpcRequest req) throws RpcException;
}

// 接口实现类：鉴权过滤器
public class AuthencationFilter implements Filter {
    @Override
    public void doFilter(RpcRequest req) throws RpcException {
        //...鉴权逻辑..
    }
}

// 接口实现类：限流过滤器
public class RateLimitFilter implements Filter {
    @Override
    public void doFilter(RpcRequest req) throws RpcException {
        //...限流逻辑...
    }
}

// 过滤器使用demo
public class Application {
    // filters.add(new AuthencationFilter());
    // filters.add(new RateLimitFilter());
    private List<Filter> filters = new ArrayList<>();

    public void handleRpcRequest(RpcRequest req) {
        try {
            for (Filter filter : fitlers) {
                filter.doFilter(req);
            }
        } catch(RpcException e) {
            // ...处理过滤结果...
        }
        // ...省略其他处理逻辑...
    }
}
```

由上述代码中，可以总结接口有如下三个特性：

1. 接口不能包含成员变量（可以包含静态常量）。
2. 接口只能声明抽象方法。
3. 当类实现接口时，必须实现接口中的所有抽象方法。

与抽象类相似，接口也不能被实例化，只能被实现。可以说接口是一种“has a”的关系。



### 为什么要使用抽象类

我们可以将上述抽象类的示例代码进行一些修改，改为父子类继承，观察有什么不同：

```java
// 父类：非抽象类, 删除了log(), doLog(), 新增了isLoggable().
public class Logger {
    private String name;
    private boolean enabled;
    private Level minPermittedLevel;

    public Logger(String name, boolean enabled, Level minPermittedLevel) {
        //...构造函数不变，代码省略...
    }

    //声明为protect, 只对同一个包下的子类可见
    protected boolean isLoggable() {
        boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
        return loggable;
    }
}

// 子类：输出日志到文件
public class FileLogger extends Logger {
    private Writer fileWriter;

    public FileLogger(String name, boolean enabled,
                      Level minPermittedLevel, String filepath) {
        //...构造函数不变，代码省略...
    }

    public void log(Level level, String mesage) {
        if (!isLoggable()) 
            return;
        // 格式化level和message, 输出到日志文件
        fileWriter.write(...);
    }
}

// 子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
    private MessageQueueClient msgQueueClient;

    public MessageQueueLogger(String name, boolean enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient) {
        //...构造函数不变, 代码省略...
    }

    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        // 格式化level和message,输出到消息中间件
        msgQueueClient.send(...);
    }
}
```

这种设计思路虽然实现了代码复用，但是无法使用多态的特性了。假设我们编写下面的代码，就会出现编译错误，因为Logger类中并没有实现log方法。

```java
Logger logger = new FileLogger("access-log", true, Level.WARN, "/users/wangzheng/access.log");
logger.log(Level.ERROR, "This is a test log message.");
```

虽然我们可以在父类中添加一个空的log()方法，让子类重写log()解决问题，但是并没有抽象类的实现优雅，原因如下：

1. 在Logger中定义空方法会影响代码的可读性。如果不熟悉Logger背后的设计思想，在阅读Logger代码时，可能对为什么存在一个空方法而感到疑惑。

2. 当创建一个新的子类继承Logger类时，也有可能忘记重写log。如果是继承抽象类，会要求强制重写抽象方法。
3. 如果Logger只是普通类，可以被实例化，那么我们可以new一个Logger实例出来，并且调用其空的log()方法，增加了类被误用的风险。



### 为什么要使用接口

接口是对行为的抽象，调用者只需要关注接口中的抽象方法，而不需要关注其具体实现，实现了约定和实现解耦，提高代码的可扩展性。我们经常说“基于接口而非实现编程”，这样能够极大地提高代码的灵活性。

实际上，**“基于接口编程而非实现” **并非局限于Java中的interface，这句话体现的是一种思想，这里的接口可以是类库提供的接口，也可以是服务端与客户端之间的接口。在软件开发中，最大的挑战就是不断变化的需求。这意味着，越抽象、越顶层、越脱离具体实现的设计就越能提高代码的灵活性，以应对未来的需求变化。而接口提供的抽象特性，就是提高代码可扩展性、灵活性、可维护性最有效的手段之一。

那么如何运用在代码中采用“基于接口编程而非实现”的思想呢？假设存在一个系统，业务涉及了很多的图片处理逻辑。图片经过处理之后被上传到阿里云服务器上。具体代码实现如下所示：

```java
public class AliyunImageStore {
    //...省略属性、构造函数等

    //如果存储目录不存在, 则创建
    public void createBucketIfNotExisting(String bucketName) {
        //...
        //...失败会抛出异常
    }

    //生成accessToken
    public String generateAccessToken() {
        //...根据accesskey/secrectkey等生成accessToken
    }

    //上传图片到阿里云
    public String uploadToAliyun(Image image, String bucketName, String accessToken) {
        ...
        //返回图片存储在阿里云上的url...
    }

    //下载图片到阿里云
    public Image downloadFromAliyun(String url, String accessToken) {
        ...
    }
}

//AliyunImageStore类的使用举例
public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    ...

    //执行方法
    public void process() {
        Image image = ...; //处理图片，并封装为Image对象
        AliyunImageStore imageStore = new AliyunImageStore(...省略参数);//初始化AliyunImageStore实例
        imageStore.createBucketIfNotExisting(BUCKET_NAME);//如果存储目录不存在, 则创建
        String accessToken = imageStore.generateAccessToken();//创建accessToken
        imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);//上传图片到阿里云
    }
}
```

上述代码看似满足了上传图片到阿里云的业务逻辑，但如果过了一段时间后，我们需要将图片改为上传到私有云上，那么我们需要重新设计实现一个存储图片到私有云的PrivateImageStore类并替换掉AliyunImageStore。那么新的PrivateImageStore需要设计实现哪些方法，才能在尽量最小化代码修改的情况下替换AliyunImageStore呢？这就要求我们将AliyunImageStore类中的所有public方法在PrivateImageStore中重新实现一遍。但这么做就可能存在下面两个问题：

1. AliyunImageStore类中有些函数暴露了实现细节，例如：uploadToAliyun()、downloadFromAliyun()这两个方法都包含了“Aliyun”这个实现细节。如果直接把AliyunImageStore中的方法照抄到PrivateImageStore类中显然不合适，但如果重新实现这些方法，代码的改动量又会很大。

2. 其次，将图片存储到aliyun的流程跟存储到私有云的流程并不是完全一致的。比如，aliyun的图片上传和下载需要生成accessToken，而私有云并不需要。这就意味着generateAccessToken()这个方法并不能直接照搬到私有云的代码实现中。

针对上面的问题，我们可以通过下面的三步解决：

1. 函数名不能暴露任何实现细节。比如uploadToAliyun()改为更加抽象的命名——upload()。
2. 封装具体的实现细节。aliyun相关的上传、下载操作不应该暴露给调用者。
3. 为实现类定义抽象接口。比如将阿里云、私有云的公有实现方法通过接口定义，调用者依赖接口进行调用而不是依赖具体实现类。

我们根据上面的思路，对上述代码进行重构：

```java
//图片处理接口
public interface ImageStore {
	//上传图片
    String upload(Image image, String bucketName);
    //下载图片
    Image download(String url);
}

//aliyun图片处理实现类
public class AliyunImageStore implements ImageStore {
    //...省略属性、构造函数等

    //实现接口中的upload
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        String accessToken = generateAccessToken();
        //...返回图片在阿里云上的url
    }

    //实现接口中的download
    public Image download(String url) {
        String accessToken = generateAccessToken();
        //...从阿里云下载图片
    }

    //如果图片存储路径不存在, 则创建
    private void createBucketIfNotExisting(String bucketName) {
        // ...创建bucket
        // ...失败会抛出异常..
    }
	
    //aliyun操作独有的方法, 生成accessToken
    private String generateAccessToken() {
        // ...根据accesskey/secrectkey等生成accessToken
    }
}

// 私有云不需要支持accessToken
public class PrivateImageStore implements ImageStore  {
    //...上传图片到私有云
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        //...返回图片的url...
    }

    public Image download(String url) {
        //...从私有云下载图片...
    }

    private void createBucketIfNotExisting(String bucketName) {
        // ...创建bucket...
        // ...失败会抛出异常..
    }
}

// ImageStore的使用举例
public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    //...省略其他无关代码...

    public void process() {
        Image image = ...;//处理图片，并封装为Image对象
        //创建私有云图片操作的实例
        ImageStore imageStore = new PrivateImageStore(...);
        //调用的是私有云的上传方法
        imagestore.upload(image, BUCKET_NAME);
    }
}
```

除此以外，很多人是通过实现类来反推接口的定义，如果按照这种方式，这样的接口设计就缺失了核心思想——抽象，这样的接口定义就没有太大意义了。所以，思路是先想好要实现功能并通过接口定义，然后再编写具体的实现。注意，接口中的定义不要暴露实现细节。

从设计初衷上来看，接口主要做的是定义和实现的解耦，带来了诸多的好处。但是也不能滥用接口，如果某个功能只有需要一个实现类实现，未来也不可能被其他方式替换，那么也没必要为其设计接口了，**因为没有扩展的可能，也就不需要提高可扩展性了**。