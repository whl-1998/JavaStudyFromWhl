### 继承的缺点

很多人认为尽量不要使用继承，那么为什么会有这种观念呢？我们可以通过如下示例进行解释：

假设我们要设计一个“鸟类”，将“鸟”这个抽象定义为类AbstractBird，而所有细分的鸟，如麻雀、鸽子等，都继承这个类。大多数鸟都会飞，于是针对该行为创建一个fly()的抽象方法。但也存在不会飞的鸟（比如鸵鸟），我们可以针对那些不会飞的鸟，对重写的fly()方法抛出异常。具体代码如下所示：

```java
public class AbstractBird {
    public void fly() {
        ...
    }
}

//鸵鸟
public class Ostrich extends AbstractBird { 
    //...省略其他属性和方法...
    
    public void fly() {
        throw new UnSupportedMethodException("I can't fly.");
    }
}
```

这种思路虽然可以解决问题，但除了鸵鸟，不会飞的鸟还有很多。对于每一个不会飞的鸟，我们都需要抛出异常，这样就徒增了编码的工作量，并且也暴露了一些不该暴露的方法给外部（外部可能会调用那些不会飞的鸟的fly()方法，这不是我们想要的），增加了类被误用的概率。

除此以外，如果还要考虑“鸟是否会下蛋”这个行为。那么可能就更加复杂了：

```java
public class AbstractBird {
    public void fly() {
        ...
    }
    
    public void layEggs() {
    	...
    }
}

//不能飞的鸟
public class UnflyAbleBird extends AbstractBird { 
    public void fly() {
        throw new UnSupportedMethodException("I can't fly.");
    }
    
    public void layEggs() {
    	...
    }
}

//能飞的鸟
public class FlyAbleBird extends AbstractBird { 
    public void fly() {
    	...
    }
    
    public void layEggs() {
    	...
    }
}

//不会飞, 不会下蛋的鸟
public class SomeBird extends UnflyAbleBird {
	public void fly() {
    	throw new UnSupportedMethodException("I can't fly.");
    }
    
    public void layEggs() {
        throw new UnSupportedMethodException("I can't lay eggs.");
    }
}
```

现在只添加两层分类逻辑就已经比较复杂了，如果再继续增加分类就不得了了。可以看到继承的缺陷十分明显：当继承层次过深，继承关系过于复杂导致代码的可读性很差；并且也破坏了类的封装性，将我们不想暴露的实现细节暴露给外部，增加了类被误用的概率；并且子类父类高耦合，父类代码修改会影响到所有子类的逻辑。



### 组合的优势

对于上述问题，我们可以利用组合、接口、委托三个技术手段解决。对于是否会飞的行为，我们可以定义一个Flyable接口，只让会飞的鸟实现这个接口。对于是否会下蛋的行为，也可以类似地定义EggLayable接口。代码如下所示：

```java
//是否会飞
public interface Flyable {
    void fly();
}

//是否会叫
public interface Tweetable {
    void tweet();
}

//是否会下蛋
public interface EggLayable {
    void layEgg();
}

//鸵鸟会下蛋、会叫
public class Ostrich implements Tweetable, EggLayable {
    //... 省略其他属性和方法...

    @Override
    public void tweet() { 
        //... 
    }
    
    @Override
    public void layEgg() { 
        //... 
    }
}

//麻雀会飞、会叫、会下蛋
public class Sparrow implements Flayable, Tweetable, EggLayable {
    //... 省略其他属性和方法...

    @Override
    public void fly() { 
        //... 
    }
    
    @Override
    public void tweet() { 
        //... 
    }
    
    @Override
    public void layEgg() { 
        //... 
    }
}
```

接口只会定义方法，不会定义实现。这就意味着，每个会飞的鸟都需要实现一遍同样的fly()方法，这就会导致代码重复的问题，针对这个问题如何解决呢？

我们可以针对三个接口再定义三个实现类，通过组合、委托技术消除代码重复：

```java
public interface Flyable {
    void fly();
}

public class FlyAbility implements Flyable {
    @Override
    public void fly() {
        //飞的具体实现
    }
}

//省略下蛋、叫的接口和实现类
//...

//鸵鸟
public class Ostrich implements Tweetable, EggLayable {
    private TweetAbility tweetAbility = new TweetAbility(); //组合, 叫
    private EggLayAbility eggLayAbility = new EggLayAbility(); //组合, 下蛋

    @Override
    public void tweet() {
        tweetAbility.tweet(); //委托, 叫
    }
    
    @Override
    public void layEgg() {
        eggLayAbility.layEgg(); //委托, 下蛋
    }
}
```

从理论上来说，通过组合、接口、委托这三个技术手段，我们完全可以替代继承。但是组合也并不是完美的，继承也并非一无是处。从上述例子中来看，继承改为组合意味着要定义更多的类和接口。这样或多或少增加了代码的复杂程度以及维护成本。

因此，我们需要根据具体情况选择不同的做法。比如，继承层次很浅、关系不复杂的场景下，就可以大胆使用继承；而继承层次很深。代码关系复杂的场景，则尽量使用组合替代继承。

当然，也存在某些场景我们必须使用继承，例如下列代码中，FeignClient是一个外部类，我们没有权限修改这部分代码，但是我们希望重写FeignClient中的encode()函数，这时只能通过继承实现：

```java
public class FeignClient {
    //...省略其他代码
    
    public void encode(String url) { 
        //原实现 
    }

    public void demofunction(FeignClient feignClient) {
        //调用了encode方法
        feignClient.encode(url);
        //...
    }
}

public class CustomizedFeignClient extends FeignClient {
    @Override
    public void encode(String url) { 
        //...重写encode的实现...
    }
}

//调用的demofunction实现是基于重写的encode方法实现的
FeignClient client = new CustomizedFeignClient();
demofunction(client);
```

