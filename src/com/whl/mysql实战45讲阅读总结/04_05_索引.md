### 常见索引模型

**索引的出现就是为了提高数据库检索的效率。**这句话或许太过于总结性，以至于我在刚接触索引时并没有很好的了解索引的概念。其实我们可以先设想一个简单的场景：如果是查询数组中的某个值，你会用什么方式去优化查询效率？

最简单的就是暴力法——遍历一次数组检索到目的值，这个时间复杂度是O(n)的，因此我们可以不考虑。如果数组序列是有序的，我们可以通过二分查找检索，这个时间复杂度是O(logN)的，似乎还不错，但是局限性太大，我们并不能保证所有情况下序列都有序，更何况每一次更新操作还会进行一次O(n)的元素挪动。

获取可以换一个数据结构，例如HashMap？我们将数组中的值交给HashMap维护，key就是元素的下标，value就是元素的值，这样检索某一个值时时间复杂度是O(1)，相当不错了，可如果是要进行范围查询，因为HashMap散列存储的特性，检索n个值就必须遍历n次HashMap，这样范围查询的时间复杂度是O(n)的，所以HashMap还不够好。

我们可以再换成二叉搜索树这个数据结构，查询时间复杂度为O(logN)，因为二叉搜索树中序遍历有序的特性，我们也可以用O(logN)的时间复杂度进行范围查询，缺点是每一次进行元素添加都需要进行一次O(logN)的维护，并且在某些极端情况下，搜索树也会退化到查询时间复杂度为O(n)的链表。

或许我们可以对二叉搜索树进行优化，限制左右子树的高度，采用平衡二叉树，例如AVL或红黑树这样类似的数据结构进行存储，就可以保证任何情况下，查询时间复杂度都是O(logN)。但是想象一下，经过平衡二叉树维护后，每一个相邻节点都不是连续的内存地址，这样会带来什么问题呢？

如果是检索内存中的数组确实没什么问题，但是不要忘记了我们的目的是建立数据库表的索引。**其实建立数据库索引和数组索引并没有什么太大的不同，都是将数据交给一个数据结构进行维护，使得我们能够通过这个数据结构更快的检索数据**。但区别在于数据表和索引是存在于硬盘上的，我们需要通过I/O设备，在硬盘中进行读写操作。我们知道I/O读写是非常耗时的工作，如果磁盘地址不连续，那么即便是通过平衡二叉树索引维护，我们在遍历二叉树索引时，每经过一个节点都需要从磁盘中读写一个位置较远的数据块，这个过程就好比今天在北京工作，明天就要出差去非洲。

那么有什么方法可以优化索引呢？既然I/O读写是非常耗时的工作，那么我们只需要尽可能减少I/O读写的次数就好了，也就是减少遍历节点的个数。那么如何减少遍历节点的个数？我们可以使每个节点存储更多的数据，并且由二叉树改为n叉树，以此减少树的高度。为此我们可以采用 B+树 这个数据结构作为索引维护数据表。

以InnoDB的一个整数字段索引为例子，这个N叉树的N差不多是1200，也就是当树高为4的时候，可以存1200的3次方个值。这就意味着我们查一个12亿的数据表最多只需要进行4次IO读写，相比起平衡二叉树已经是质的提升了。



### InnoDB索引引擎

在InnoDB中，表是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。并且InnoDB采用了B+树的数据结构作为索引，每一个索引在InnoDB对应着一棵B+树。

而InnoDB的索引又分为主键索引和非主键索引，主键索引叶子节点存储的是整行数据，非主键索引的叶子节点存储的是主键的值。假设我们存在一个数据表，表中有字段k，并且k上有索引，建表语句如下：

```mysql
create table T(id int primary key, k int not null, name varchar(16),index (k)) engine=InnoDB;
```

如果是主键查询 select * from T where id = xxx，则需要搜索id这棵B+树；如果是普通索引查询 select * from T where k = xxx，则需要先搜索k这个B+树，找到对应的主键id，然后根据这个主键id再次搜索id这棵B+树。这个过程称为回表，即基于非主键查询需要多扫描一棵索引树，因此在应用中应该尽可能使用主键查询。



### 索引维护

B+ 树为了维护索引的有序性，在插入新值时需要进行必要的维护。例如下图，如果在ID这棵树中插入新值700，则仅需要在R5后面追加一个700的记录，但如果是要插入新值400，就需要逻辑移动500后续的记录以空出位置。但假设R5所在的数据页已经满了，那么根据B+树的算法需要新开辟一个数据页，然后挪动部分数据过去，这个过程被称为页分裂，这种情况下性能会受到一定的影响，除此以外，页分裂也会影响数据页的利用率。当相邻两个页由于删除了数据导致利用率很低之后会将数据页做合并，合并的过程可以认为是分裂过程的逆过程，这个过程也是相当消耗资源的操作，因此我们要尽量避免页分裂和页合并。

<img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:70%;" />

那么如何避免页分裂、页合并呢？我们在建立数据库表时，总是会指定主键自动递增，原因是这样每一次添加操作都是追加操作，不涉及挪动其他记录，也不涉及页分裂的过程，空间利用率和效率都有明显的提升。



### 覆盖索引

select * from T where k between 3 and 5，这条sql语句会在k的索引树读取3条记录，进行两次回表。但如果执行的语句是：select id from T where k between 3 and 5，k的索引树中就包含了我们要查询的字段记录，因此就避免了回表过程。这样的“索引覆盖了我们的查询需求”被称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，因此能够显著提升效率，因此覆盖索引也是一个常见的性能优化手段。

这里值得注意的是，虽然在引擎层读取了3条记录，但是返回给server层的记录只有2条，因此mysql会认为扫描行数是2.

假设存在一个市民表如下：

```mysql
CREATE TABLE `tuser` (
    `id` int(11) NOT NULL,
    `id_card` varchar(32) DEFAULT NULL,
    `name` varchar(32) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    `ismale` tinyint(1) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `id_card` (`id_card`),
    KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

如果有**根据身份证号查询市民信息的需求**，我们只需要在身份证号字段上建立索引即可，如果再建立一个（身份证号，姓名）的联合索引是否有点多余？

但如果现在有个高频请求，要**根据身份证号查询市民姓名的需求**，这个联合索引就很有意义了，通过（身份证号，姓名）这个联合索引，我们不需要回表查询整行的市民信息记录，而是只需要通过这个联合索引直接获取到姓名字段的记录即可，大大减少了语句的执行时间。（这是一种通过覆盖索引的方式进行查询优化）

缺点是，维护冗余索引的维护是有代价的，当更新数据时，要更新的索引也就更多，此时就需要权衡了，如果是查询更多的业务场景，我个人觉得很有必要建立覆盖索引。



### 最左前缀原则

假设现在又多了一个新的需求，**需要根据身份证号查询地址**，虽然这个查询需求在业务中并不高，但总不能进行一次全表扫描吧，但是为了这个需求创建一个（身份证号，地址）的索引又感觉不是很有必要。此时应该怎么做？

这时我们可以利用索引的“最左前缀”原则，来定位记录：我们可以通过（身份证号，姓名）这个之前就创建的索引来支持“根据身份证号查询地址”的需求，可以理解为（身份证号，姓名）这个索引就包含了（身份证号）这个索引，所以当已经有了 (身份证号，姓名) 这个联合索引后，一般就不需要单独在（身份证号）上建立索引了。此时的查询流程是，通过（身份证号，姓名）这个索引检索到对应身份证的主键id，然后进行一次回表，根据主键id检索对应的地址记录。

因此，如果通过调整联合索引的顺序能够少维护一个索引，例如（a，b）这个联合索引也可以支持索引（a），那么这个顺序往往就是需要优先考虑采用的。



### 索引下推

以联合索引（name，age）为例，假设我们需要检索出表中“名字第一个是张，而且年龄是18岁的所有男生”，那么sql语句如下：

```mysql
select * from tuser where name like `张%` and age=18 and ismale=1;
```

首先根据最左前缀原则，首先会检索出表中符合条件的name字段的主键id，然后再判断其他条件是否满足。

在mysql5.6之前，获取到符合条件的主键id之后，需要通过主键id回表到主键索引上查找出对应数据行，然后继续比较字段是否符合条件。

而在mysql5.6引入的索引下推优化，可以在检索表中符合条件的name字段同时，对索引中包含的age字段先作判断，直接过滤掉不满足条件的记录，省去了很多回表的过程。



### 问题记录

##### 1. select * from table where id＝xx 和 select id from table where id＝xx 都是去id这棵索引树检索所有行，它们效率一样么

不一样，select * 要读取和拷贝更多的列到server，还要发送更多的列给客户端，因此select id的效率更快。



##### 2. 一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，原因是主键索引和数据行在一起，非常大搜索慢，通过普通索引找到主键ID后，不还是需要进行回表查询么，为什么二级索引的搜索会比主键快呢？

如果检索的是主键id字段，二级索引搜索是会比主键更快的，因为不需要回表，这种情况就是覆盖索引。或者使用的是联合索引，且在mysql5.6版本通过索引下推优化机制，也可以直接检索出联合索引中包含的值，不需要回表。



##### 3.