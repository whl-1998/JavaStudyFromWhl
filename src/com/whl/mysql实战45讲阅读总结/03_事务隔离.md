### 事务

事务需要具备“ACID”（原子性、一致性、隔离性、持久性）四个特性，最常见的事务场景就是银行的转账业务，转账过程具体到程序中涉及到一系列的操作，包括读取账户余额，减去转账金额，更新结果。

假设whl1，whl2两个人同时用账户A给账户B转账100，而账户A的余额有100，在读取账户A的余额时，whl1和whl2都能同时读取到账户余额为100，并进行后续操作，执行结果是账户B最终会收到200元，这样的**“两个事务同时进行，其中一个事务读取到了另一个事务还没有提交的数据”**，就造成了隔离性问题。

又或者，当账户A给账户B转账100时，在减去转账金额操作后，突然银行断电，这样账户A减去了100元，而账户B却因为停电并不能收到100元，这样的**“一个转账动作（包含一系列操作）只发生了其中的几个动作，而不是一起成功或一起失败”**就造成了原子性问题；并且因为断电，这样的的**“操作前后，数据库状态不一致（A账户余额=0，B账户余额100）”**就造成了持久性问题；而**“操作前后，结果不符合逻辑运算”**，也造成了一致性问题。

在mysql中，事务在引擎层实现，但并非所有引擎都支持事务，比如MyISAM就不支持，这也是它被InnoDB取代的原因之一。



### mysql的事务隔离

当数据库上有多个事务同时执行，就可能出现脏读、幻读、不可重复读的问题。

##### 1. 脏读

脏读就是上述例子中，当一个事务的结果还未提交时，另一个事务也访问并且使用了这个数据。

##### 2. 不可重复读

不可重复读，就是账户B连续读取两次账户余额，第一次读是100，在第二次读之前，账户B收到了一份转账100，于是第二次读是200。这样的多次读取内容不一致，就是不可重复读。

##### 3. 幻读

幻读，就是银行第一次读取“余额为100的账户”有10个，在第二次读之前，其中一个账户转账了100操作，于是银行第二次读取“余额为100的账户”就变成了9个。幻读和不可重复读十分相似，区别在于幻读是针对多条数据，而脏读只针对同一条数据。

为了解决这些问题，才引入了“隔离级别”的概念。但是隔离的越严实，效率就越低。SQL标准的事务隔离级别包括了“读未提交”、“读提交”、“可重复读”、“串行化”：

##### 1. 读未提交

当一个事务还未提交，它做的变更就能够被其他事务看到。

##### 2. 读提交

当一个事务提交，它做的变更才能被其他事务看到。mysql默认采用的就是“读提交”隔离级别。

##### 3. 可重复度

当一个事务执行过程中看到的数据，总是与这个事务启动前看到的数据一致的。可重复读的使用常出现在“数据校对逻辑”场景下。例如，whl需要通过上个月的余额表与当前的余额表计算差额，在校对过程中，一定不希望因为当前余额表的某行数据更新从而影响到校对结果，此时采用“可重复读”的隔离级别就很方便。

##### 4. 串行化

对同一行记录，读加读锁、写加写锁。当出现读写锁冲突时，后访问的事务必须等待前一个事务执行完成。



#### 事务隔离的具体实现

在mysql中，每条记录在更新时都会记录回滚操作，通过回滚日志，就可以得到之前状态的值。当没有事务需要用到这些回滚日志时，系统会自动删除。但如果使用长事务，需要保存的回滚日志就更多，这会导致大量占用存储空间。

