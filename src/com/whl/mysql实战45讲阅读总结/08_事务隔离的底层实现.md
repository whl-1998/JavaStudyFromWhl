Mysql默认采用的隔离级别是repeatable-read，也就是可重复读，在这个隔离级别下，事务执行时看到的数据与事务启动前看到的数据保持一致。因为在可重复读隔离级别下，事务A启动时会创建一个视图read-view，之后在事务A执行期间看到的数据都以这个read-view为准。

如果事务A需要更新一行，如果另一个事务拥有这一行的行锁，事务A就会进入等待状态。那么等到事务A获取到行锁结束等待后，事务A读取到的值又是什么呢？

假设存在一个表如下：

```mysql
CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `k` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```

并按下图所示，开启事务A、B、C：

![img](https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png)

需要注意的是：“begin/start transaction”这个语句并不是一个事务的起点，当我们执行这条语句时，只有当执行到第一个操作InnoDB表的语句时，一致性视图才会创建，事务才会真正的启动。如果想要马上启动一个事务，创建一致性视图，需要执行“start transaction with consistent snapshot”这个语句。

事务A查到的k值是1，因为一致性视图创建在事务B、C之前，这个没有疑问。

但事务B最后查到的k值就不一定了，因为事务隔离级别是可重复读，事务B会在事务C的更新语句之前创建视图，按道理来说是事务B是看不见事务C的更新动作的。如果是这样，事务B查到的k值应该是2，但这就存在一个问题。想象一下，事务B在查到k的值是2之后，又基于查到的k=2对数据进行更新，那么这个更新的结果就会覆盖掉事务C的更新。因此，上述的流程是不可取的。我们知道数据库的更新操作本质上就是：先在引擎层读取到值，然后在server层将值进行更新，然后将更新结果回写到引擎层。那么针对上面的问题，mysql在可重复读的隔离级别下建立了这么一个规则：在引擎层读取值时，每次读取的都是最新的值，这个读被称为“当前读”。也就是说事务B在执行更新时，读取到的 k 是事务C更新之后的 k。这样就确保了事务C不会丢失。最后，上图中事务B读取到的k值也就是3。

这里的当前读操作，除了更新语句外，select语句如果加锁，例如，给select语句加上“for update”或“lock in share mode”，此时的读操作也是当前读。

那么这个当前读操作是如何实现的呢？这就需要依赖mysql的“快照”功能了。

“快照”就好比是《蝴蝶效应》电影中，男主通过自己18岁拍的照片穿越到照片当时的场景。mysql也是一样的，通过拍一张快照，之后可以通过这张快照将状态回滚到这个快照的时段。在可重复读的隔离级别下，事务在启动的时候就拍了一张快照。需要注意的是，这个快照是基于整个库的。

听起来似乎不太现实，假设一个库有100G，启动一个事务拍快照的时候就需要拷贝100G的数据，这显然是很慢的。但实际上，mysql的快照是不会采取这种笨办法的。

InnoDB中，每个事务都有一个唯一的事务id —— transaction_id，它是在事务开始时向InnoDB事务系统申请的，且按照申请顺序严格递增。

并且每行数据也都是有多个版本的，每次事务更新数据时，都会生成一个新的数据，并且把transaction_id赋值给这个新数据的trx_id列中，同时，旧版本也需要保留，并在新版的数据中用指针指向上一个旧版本的...





按照可重复读的概念，一个事务启动时，能够看到所有已经提交的事务结果。在这个事务的执行期间，其他事务的更新对它不可见。

实际上，InnoDB为每个事务构建了一个数据用于保存事务启动瞬间，当前正在活跃的所有事务的transaction_id。活跃事务指的是，事务启动了但是还未提交。

在数组中transaction_id最小的记为低水位，当前系统里创建过的事务的transaction_id最大的记为高水位，这个视图数组 + 高水位就构成了当前事务的一致性视图。

![img](https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png)

这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1. 如果在绿色部分，表示这个版本是已经提交的事务或是当前事务自己生成的，数据可见。

2. 如果在黄色部分，包含两种情况：1、若row trx_id在数组中，表示这个版本由还没提交的事务生成，不可见；2、若row trx_id不在数组中，表示这个版本由已经提交的事务生成，可见。
3. 如果在红色部分，表示这个版本由将来启动的事务生成，不可见。

