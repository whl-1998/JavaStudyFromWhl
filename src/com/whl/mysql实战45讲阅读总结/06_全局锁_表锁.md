### 全局锁

全局锁就是对整个数据库进行加锁，可以通过命令Flush tables with read lock执行。当需要整个库处于只读状态时，可以执行这个命令，之后其他线程的以下语句会被阻塞：更新语句、定义语句（建表、修改表结构等）、更新类事务的提交语句。

至于为什么是使用“Flush tables with read lock”而不是“set global readonly=true”，有如下两个原因：

1. 在有些系统中，readonly的值会被用来做一些其他逻辑，比如判断一个库是主库还是从库。
2. 如果执行FTWRL命令之后，由于客户端发生异常断开，那么mysql会自动释放这个全局锁；但如果执行的是set global readonly=true，如果客户端发生异常，则数据库会一直保持readonly的状态，从而导致整个库长时间处于不可写状态。

全局锁主要使用在“做全库逻辑备份”场景下，也就是将整个库每个表都select存为文本。但是让整个数据库处于只读状态是非常危险的，如果全局锁锁的是主库，那么在此期间业务基本就得停摆；如果全局锁锁的是从库，那么备份期间从库就不能执行主库同步过来的binlog，从而导致主从库延迟。

为此，如果我们采用的是InnoDB引擎，可以采取可重复读的事务隔离级别，使“备份”这个事务获取到的数据总是事务最开始的视图。



### 表级锁

mysql中的表级锁有两种：表锁、元数据锁。

表锁的语法是“lock tables (tableName1) read/write, (tableName2) read/write”，与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开连接时自动释放。

需要注意的是，lock tables这个操作不仅会限制其他线程的读写，也会限制此线程的读写。例如：线程A执行了“lock tables t1 read, t2 write”，则其他线程写t1，读写t2时会被阻塞。同时，线程A自身也只能执行读t1，读写t2的操作。

但对于InnoDB引擎，一般不采用lock tables控制并发，而是采用更细粒度的行级锁。

元数据锁MDL，它不需要显示使用，而是在访问一个表时自动加上，作用是保证读写的正确性。典型的场景例如，当一个线程的查询操作正在遍历整个表中的数据，但执行期间另一个线程对表的结构做了变更，那么查询操作获得的结果一定与更新后的表结构是不对应的，此时就需要依赖MDL。

mysql在5.5版本引入了MDL，在对某个表做增删改查操作时，加上MDL读锁；当对表做结构变更操作时，加上MDL写锁。

读锁本身不互斥，因此可以存在多个线程同时对一张加了读锁的表进行增删改查。

读写锁、写锁之间是互斥的，用来保证变更表结构的安全性，因此，如果存在多个线程同时给一个表加上一个字段，其他线程必须等待持有锁的线程执行完毕。

