首先是mysql的逻辑架构图：

<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom:50%;" />

从总体上来说，mysql主要分为server层和引擎层两个部分，而server层包括下面几个模块：

##### 1. 连接器

首先，要使用mysql必须要先通过输入用户名、密码访问服务端，如果连接器验证密码不正确则会抛出一个错误，然后客户端执行结束。

如果验证通过，连接器会到权限表中查询登陆的用户拥有的权限，之后这个用户的所有权限判断逻辑，都依赖于此时读到的权限。这就意味着，如果某个用户成功登陆后，如果之后被管理员修改了权限，服务端也会依赖登陆成功时的权限进行校验，直到该用户重新登陆才会受到影响。

当客户端成功登陆后，如果长时间没有执行任务，连接器就会自动断开与客户端的连接，这个时间默认为8h。

数据库中，连接又分为长连接、短连接。长连接指连接成功后，如果客户端持续请求，则一直使用同一个连接；短连接指每次执行很少的查询就断开连接，下次再重新建立连接。建立连接通常是比较耗时的一个操作，因此建议尽量使用长连接。

但是，mysql在执行过程中，临时使用的内存是管理在连接对象中的，只有断开连接后才会释放内存。如果使用长连接就会导致内存占用太大，造成OutOfMemory异常后被系统强行关闭。

mysql在5.7版本对这个问题进行了解决：在每次执行了一个较大的操作后，会通过执行 mysql_reset_connection 重新初始化连接资源，释放掉占用内存，并且这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



##### 2. 查询缓存

当执行一个select语句时，会先去查询缓存中检查这个select语句是否执行过，如果执行过则直接返回。之前执行的select语句会以key - value的形式存储在缓存中。key是查询语句，value是结果。

但缓存的命中率在实际应用中是相当低的，每当进行一次更新操作，缓存都会被清空。如果业务是一张静态表，很长时间才会更新一次，这种场景下才适合使用查询缓存。

我们可以设置参数query_cache_type设置为DEMAND，这样mysql默认不使用查询缓存，而对于想要使用查询缓存的语句，可以通过SQL_CACHE显示指定：

```mysql
mysql> select SQL_CACHE * from T where ID=10;
```

mysql在8.0版本删除了查询缓存功能。



##### 3. 分析器

当输入一个sql语句，分析器会对语句进行“翻译”，判断sql语句是否满足mysql的语法规则，并根据翻译的结果，识别这个sql语句具体是需要做什么。



##### 4. 优化器

优化器会对分析器“翻译”的执行内容进行优化，例如：当表中存在多个索引时，决定使用哪一个索引；当语句中有多表关联时，决定各个表的连接顺序。



##### 5. 执行器

执行器会执行优化后的执行内容，开始会判断表这个语句是否具备执行操作的权限，如果没有权限则报错（如果命中查询缓存，会在返回结果之前做权限验证），如果有权限，则交给引擎层执行相关操作。



### 问题汇总

##### 1. 如果表 T 中没有字段 k，但执行了这个语句 select * from T where k = 1, 那肯定是会报 “Unknown column ‘k’ in ‘where clause'"这个错误。你觉得这个错误是哪个阶段报出来的呢？

首先想到的答案是执行器，因为执行时才会去表中获取数据，但是 k 是字段并不是数据，所以执行器一定错误。

也可能会是优化器，因为优化器会在选择使用 k 的索引查询时判断出字段 k 不存在，但mysql并不是这么设计的...

答案是分析器，mysql会在语句分析阶段就判断表中的字段是否存在。